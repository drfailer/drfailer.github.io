<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>serializer-cpp: serializer::Serializer&lt; MemT, TypeTable, AdditionalTypes &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">serializer-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structserializer_1_1Serializer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structserializer_1_1Serializer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">serializer::Serializer&lt; MemT, TypeTable, AdditionalTypes &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Default serializer that contains the functions for serializing and deserializing types from the standard library. It inherits from the convert behavior for additional types so the user can add its own functions.  
 <a href="structserializer_1_1Serializer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="serializer_2serializer_8hpp_source.html">serializer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for serializer::Serializer&lt; MemT, TypeTable, AdditionalTypes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structserializer_1_1Serializer__inherit__graph.png" border="0" usemap="#aserializer_1_1Serializer_3_01MemT_00_01TypeTable_00_01AdditionalTypes_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aserializer_1_1Serializer_3_01MemT_00_01TypeTable_00_01AdditionalTypes_01_4_inherit__map" id="aserializer_1_1Serializer_3_01MemT_00_01TypeTable_00_01AdditionalTypes_01_4_inherit__map">
<area shape="rect" title="Default serializer that contains the functions for serializing and deserializing types from the stand..." alt="" coords="5,95,229,151"/>
<area shape="rect" href="structserializer_1_1Serialize.html" title=" " alt="" coords="40,5,195,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for serializer::Serializer&lt; MemT, TypeTable, AdditionalTypes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structserializer_1_1Serializer__coll__graph.png" border="0" usemap="#aserializer_1_1Serializer_3_01MemT_00_01TypeTable_00_01AdditionalTypes_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aserializer_1_1Serializer_3_01MemT_00_01TypeTable_00_01AdditionalTypes_01_4_coll__map" id="aserializer_1_1Serializer_3_01MemT_00_01TypeTable_00_01AdditionalTypes_01_4_coll__map">
<area shape="rect" title="Default serializer that contains the functions for serializing and deserializing types from the stand..." alt="" coords="5,95,229,151"/>
<area shape="rect" href="structserializer_1_1Serialize.html" title=" " alt="" coords="40,5,195,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a266fa5e11a0ea12f36e0a1c5100ab88a"><td class="memItemLeft" align="right" valign="top"><a id="a266fa5e11a0ea12f36e0a1c5100ab88a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type_table</b> = TypeTable</td></tr>
<tr class="separator:a266fa5e11a0ea12f36e0a1c5100ab88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb81aefe06a61ff71bf4c9afbe4577e3"><td class="memItemLeft" align="right" valign="top"><a id="afb81aefe06a61ff71bf4c9afbe4577e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>id_type</b> = typename TypeTable::id_type</td></tr>
<tr class="separator:afb81aefe06a61ff71bf4c9afbe4577e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f564b06000dd31f5bd0a62f88b61e8b"><td class="memItemLeft" align="right" valign="top"><a id="a4f564b06000dd31f5bd0a62f88b61e8b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a4f564b06000dd31f5bd0a62f88b61e8b">mem_type</a> = MemT</td></tr>
<tr class="memdesc:a4f564b06000dd31f5bd0a62f88b61e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias to the type of the momory buffer <br /></td></tr>
<tr class="separator:a4f564b06000dd31f5bd0a62f88b61e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6100db274852fa2b23c6ebaec0a658"><td class="memItemLeft" align="right" valign="top"><a id="ace6100db274852fa2b23c6ebaec0a658"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ace6100db274852fa2b23c6ebaec0a658">byte_type</a> = std::remove_cvref_t&lt; decltype(<a class="el" href="structserializer_1_1Serializer.html#a9ae388da2e394cb63d21926359c22297">mem</a>[0])&gt;</td></tr>
<tr class="memdesc:ace6100db274852fa2b23c6ebaec0a658"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias to the byte type <br /></td></tr>
<tr class="separator:ace6100db274852fa2b23c6ebaec0a658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad7c3270125fb0afbe63cf0d4292400e8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ad7c3270125fb0afbe63cf0d4292400e8">Serializer</a> (MemT &amp;<a class="el" href="structserializer_1_1Serializer.html#a9ae388da2e394cb63d21926359c22297">mem</a>, size_t <a class="el" href="structserializer_1_1Serializer.html#a50d638ee5130e873a5b1b767c1c829e6">pos</a>=0)</td></tr>
<tr class="memdesc:ad7c3270125fb0afbe63cf0d4292400e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from memory buffer reference and position.  <a href="structserializer_1_1Serializer.html#ad7c3270125fb0afbe63cf0d4292400e8">More...</a><br /></td></tr>
<tr class="separator:ad7c3270125fb0afbe63cf0d4292400e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edbee2456c218489faf3ea85261e443"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a9edbee2456c218489faf3ea85261e443">append</a> (const <a class="el" href="structserializer_1_1Serializer.html#ace6100db274852fa2b23c6ebaec0a658">byte_type</a> *bytes, size_t nbBytes)</td></tr>
<tr class="memdesc:a9edbee2456c218489faf3ea85261e443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a buffer of byptes to the memory (mem and pos are changed)  <a href="structserializer_1_1Serializer.html#a9edbee2456c218489faf3ea85261e443">More...</a><br /></td></tr>
<tr class="separator:a9edbee2456c218489faf3ea85261e443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad732d2eabf09c34f63b54ded052e3ff8"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ad732d2eabf09c34f63b54ded052e3ff8">append</a> (auto &amp;&amp;elt)</td></tr>
<tr class="memdesc:ad732d2eabf09c34f63b54ded052e3ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for appending a simple elements to the memory buffer.  <a href="structserializer_1_1Serializer.html#ad732d2eabf09c34f63b54ded052e3ff8">More...</a><br /></td></tr>
<tr class="separator:ad732d2eabf09c34f63b54ded052e3ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d323568a1913ae29cdc41e2809c75e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9d323568a1913ae29cdc41e2809c75e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#aa9d323568a1913ae29cdc41e2809c75e">deserializeSize</a> ()</td></tr>
<tr class="memdesc:aa9d323568a1913ae29cdc41e2809c75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for deserializing the size of containers.  <a href="structserializer_1_1Serializer.html#aa9d323568a1913ae29cdc41e2809c75e">More...</a><br /></td></tr>
<tr class="separator:aa9d323568a1913ae29cdc41e2809c75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2714eae4da0664485d80fa5dc0f659e"><td class="memItemLeft" align="right" valign="top">constexpr id_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ab2714eae4da0664485d80fa5dc0f659e">deserializeId</a> ()</td></tr>
<tr class="memdesc:ab2714eae4da0664485d80fa5dc0f659e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an identifier.  <a href="structserializer_1_1Serializer.html#ab2714eae4da0664485d80fa5dc0f659e">More...</a><br /></td></tr>
<tr class="separator:ab2714eae4da0664485d80fa5dc0f659e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8a1f270e5f921d88efba2237b18dfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c8a1f270e5f921d88efba2237b18dfc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a2c8a1f270e5f921d88efba2237b18dfc">requires</a> (<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a2c8a1f270e5f921d88efba2237b18dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> a generic type registed in the type table.  <a href="structserializer_1_1Serializer.html#a2c8a1f270e5f921d88efba2237b18dfc">More...</a><br /></td></tr>
<tr class="separator:a2c8a1f270e5f921d88efba2237b18dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266bf13770279ce40f906e4fface43ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a266bf13770279ce40f906e4fface43ae"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a266bf13770279ce40f906e4fface43ae">requires</a> (<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a266bf13770279ce40f906e4fface43ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> a generic type registed in the type table.  <a href="structserializer_1_1Serializer.html#a266bf13770279ce40f906e4fface43ae">More...</a><br /></td></tr>
<tr class="separator:a266bf13770279ce40f906e4fface43ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3439d043e211277eed3107a974d88897"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3439d043e211277eed3107a974d88897"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a3439d043e211277eed3107a974d88897">requires</a> (<a class="el" href="namespaceserializer_1_1concepts.html#aba8e9255844b9ce33c2d22cecc312ac4">concepts::NonAutomaticSerialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a3439d043e211277eed3107a974d88897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fallback functions for non serializable types. Here either we use a custom function if it has be implemented or we throw an exception. Note: exceptions are a way to control the display of the error message. We could use a static assert but the message will be lost in the hole compiler error output.  <a href="structserializer_1_1Serializer.html#a3439d043e211277eed3107a974d88897">More...</a><br /></td></tr>
<tr class="separator:a3439d043e211277eed3107a974d88897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddd344bc11fc894dce52583580915a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38ddd344bc11fc894dce52583580915a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a38ddd344bc11fc894dce52583580915a">requires</a> (<a class="el" href="namespaceserializer_1_1concepts.html#adc3c62a906cfd8798e058a8ff1ae4f44">concepts::NonAutomaticDeserialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a38ddd344bc11fc894dce52583580915a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fallback functions for non deserializable types. Here either we use a custom function if it has be implemented or we throw an exception. Note: exceptions are a way to control the display of the error message. We could use a static assert but the message will be lost in the hole compiler error output.  <a href="structserializer_1_1Serializer.html#a38ddd344bc11fc894dce52583580915a">More...</a><br /></td></tr>
<tr class="separator:a38ddd344bc11fc894dce52583580915a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0311a534c9734337cc63040a7eb1bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe0311a534c9734337cc63040a7eb1bb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#afe0311a534c9734337cc63040a7eb1bb">requires</a> (<a class="el" href="namespaceserializer_1_1concepts.html#a7a51c9c68e56bee183b33f3d11f0f20f">concepts::UseSerialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:afe0311a534c9734337cc63040a7eb1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the serializable types (they have a serialize method).  <a href="structserializer_1_1Serializer.html#afe0311a534c9734337cc63040a7eb1bb">More...</a><br /></td></tr>
<tr class="separator:afe0311a534c9734337cc63040a7eb1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69ba041aeb1db8f89dc9963802a6f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f69ba041aeb1db8f89dc9963802a6f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a7f69ba041aeb1db8f89dc9963802a6f9">requires</a> (<a class="el" href="namespaceserializer_1_1concepts.html#ac86a00ea591f3e6c068e90d187e9b821">concepts::UseDeserialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a7f69ba041aeb1db8f89dc9963802a6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for the deserializable types (they have a deserialize method).  <a href="structserializer_1_1Serializer.html#a7f69ba041aeb1db8f89dc9963802a6f9">More...</a><br /></td></tr>
<tr class="separator:a7f69ba041aeb1db8f89dc9963802a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab592c0b1ac804a47cbcfd9395d8267f5"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Trivial T&gt; </td></tr>
<tr class="memitem:ab592c0b1ac804a47cbcfd9395d8267f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ab592c0b1ac804a47cbcfd9395d8267f5">requires</a> (!<a class="el" href="namespaceserializer_1_1concepts.html#ae4a8d3af82a1dd777f5d22860e075374">concepts::Serializable</a>&lt; T, MemT &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:ab592c0b1ac804a47cbcfd9395d8267f5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the trivial types.  <a href="structserializer_1_1Serializer.html#ab592c0b1ac804a47cbcfd9395d8267f5">More...</a><br /></td></tr>
<tr class="separator:ab592c0b1ac804a47cbcfd9395d8267f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb05c5b5ad1decb541e97ead66ffcc9"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Trivial T&gt; </td></tr>
<tr class="memitem:adbb05c5b5ad1decb541e97ead66ffcc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#adbb05c5b5ad1decb541e97ead66ffcc9">requires</a> (!<a class="el" href="namespaceserializer_1_1concepts.html#ad3aec2f2cffd4e288c5add840bbaa59f">concepts::Deserializable</a>&lt; T, MemT &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:adbb05c5b5ad1decb541e97ead66ffcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for the trivial types.  <a href="structserializer_1_1Serializer.html#adbb05c5b5ad1decb541e97ead66ffcc9">More...</a><br /></td></tr>
<tr class="separator:adbb05c5b5ad1decb541e97ead66ffcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92946fe12710a000adc48bf84b080710"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Pointer T&gt; </td></tr>
<tr class="memitem:a92946fe12710a000adc48bf84b080710"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a92946fe12710a000adc48bf84b080710">requires</a> (!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a92946fe12710a000adc48bf84b080710"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the pointer types. The pointer should be valid (nullptr or value).  <a href="structserializer_1_1Serializer.html#a92946fe12710a000adc48bf84b080710">More...</a><br /></td></tr>
<tr class="separator:a92946fe12710a000adc48bf84b080710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::ConcretePtr T&gt; </td></tr>
<tr class="memitem:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ad958d6cb0e3be7e4052dda5f1fb138a3">requires</a> (!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for the pointer types. If the pointer is not null, a dynamic allocation is done. This memory should be handled by the user.  <a href="structserializer_1_1Serializer.html#ad958d6cb0e3be7e4052dda5f1fb138a3">More...</a><br /></td></tr>
<tr class="separator:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92946fe12710a000adc48bf84b080710"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::SmartPtr T&gt; </td></tr>
<tr class="memitem:a92946fe12710a000adc48bf84b080710"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a92946fe12710a000adc48bf84b080710">requires</a> (!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a92946fe12710a000adc48bf84b080710"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for smart pointers (unique and shared). The pointer should be valid (nullptr or value).  <a href="structserializer_1_1Serializer.html#a92946fe12710a000adc48bf84b080710">More...</a><br /></td></tr>
<tr class="separator:a92946fe12710a000adc48bf84b080710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::ConcreteSmartPtr T&gt; </td></tr>
<tr class="memitem:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ad958d6cb0e3be7e4052dda5f1fb138a3">requires</a> (!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for smart pointers (unique and shared). A pointer is allocated if required.  <a href="structserializer_1_1Serializer.html#ad958d6cb0e3be7e4052dda5f1fb138a3">More...</a><br /></td></tr>
<tr class="separator:ad958d6cb0e3be7e4052dda5f1fb138a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28d294f087c1d1bcc91b564226a864d"><td class="memTemplParams" colspan="2">template&lt;size_t... Idx&gt; </td></tr>
<tr class="memitem:ae28d294f087c1d1bcc91b564226a864d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ae28d294f087c1d1bcc91b564226a864d">serializeTuple</a> (auto &amp;&amp;elt, std::index_sequence&lt; Idx... &gt;)</td></tr>
<tr class="memdesc:ae28d294f087c1d1bcc91b564226a864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function used to serialize tuples.  <a href="structserializer_1_1Serializer.html#ae28d294f087c1d1bcc91b564226a864d">More...</a><br /></td></tr>
<tr class="separator:ae28d294f087c1d1bcc91b564226a864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794704114d900d49f9132c64fc0378d4"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::TupleLike T&gt; </td></tr>
<tr class="memitem:a794704114d900d49f9132c64fc0378d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a> (T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a794704114d900d49f9132c64fc0378d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for tuples (std::tuple and std::pair).  <a href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">More...</a><br /></td></tr>
<tr class="separator:a794704114d900d49f9132c64fc0378d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a591c0dea09f516c6b69bf3ca3265"><td class="memTemplParams" colspan="2">template&lt;size_t... Idx&gt; </td></tr>
<tr class="memitem:ade0a591c0dea09f516c6b69bf3ca3265"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ade0a591c0dea09f516c6b69bf3ca3265">deserializeTuple</a> (auto &amp;&amp;elt, std::index_sequence&lt; Idx... &gt;)</td></tr>
<tr class="memdesc:ade0a591c0dea09f516c6b69bf3ca3265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for deserializing tuples.  <a href="structserializer_1_1Serializer.html#ade0a591c0dea09f516c6b69bf3ca3265">More...</a><br /></td></tr>
<tr class="separator:ade0a591c0dea09f516c6b69bf3ca3265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34506a0ccca983d12caaaebb444f6532"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::TupleLike T&gt; </td></tr>
<tr class="memitem:a34506a0ccca983d12caaaebb444f6532"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a> (T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a34506a0ccca983d12caaaebb444f6532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function tuples (std::tuple and std::pair).  <a href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">More...</a><br /></td></tr>
<tr class="separator:a34506a0ccca983d12caaaebb444f6532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46af9ccd91e0bf353daecdfd44b6a276"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Enum T&gt; </td></tr>
<tr class="memitem:a46af9ccd91e0bf353daecdfd44b6a276"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a46af9ccd91e0bf353daecdfd44b6a276">requires</a> (!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a46af9ccd91e0bf353daecdfd44b6a276"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the enum types. The underlying type is used to store the data.  <a href="structserializer_1_1Serializer.html#a46af9ccd91e0bf353daecdfd44b6a276">More...</a><br /></td></tr>
<tr class="separator:a46af9ccd91e0bf353daecdfd44b6a276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192faa421c46d03b8a40a77280ab503e"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Enum T&gt; </td></tr>
<tr class="memitem:a192faa421c46d03b8a40a77280ab503e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a192faa421c46d03b8a40a77280ab503e">requires</a> (!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a192faa421c46d03b8a40a77280ab503e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for enum types. The data is stored using the underlying type.  <a href="structserializer_1_1Serializer.html#a192faa421c46d03b8a40a77280ab503e">More...</a><br /></td></tr>
<tr class="separator:a192faa421c46d03b8a40a77280ab503e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794704114d900d49f9132c64fc0378d4"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::String T&gt; </td></tr>
<tr class="memitem:a794704114d900d49f9132c64fc0378d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a> (T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a794704114d900d49f9132c64fc0378d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for strings.  <a href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">More...</a><br /></td></tr>
<tr class="separator:a794704114d900d49f9132c64fc0378d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e372fa1e13b701e10be2f40806f6205"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::String T&gt; </td></tr>
<tr class="memitem:a0e372fa1e13b701e10be2f40806f6205"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a0e372fa1e13b701e10be2f40806f6205">deserialize_</a> (T &amp;&amp;str)</td></tr>
<tr class="memdesc:a0e372fa1e13b701e10be2f40806f6205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for strings.  <a href="structserializer_1_1Serializer.html#a0e372fa1e13b701e10be2f40806f6205">More...</a><br /></td></tr>
<tr class="separator:a0e372fa1e13b701e10be2f40806f6205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cc9953cfff5aa330bb26e4034caed6"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Container T&gt; </td></tr>
<tr class="memitem:ad0cc9953cfff5aa330bb26e4034caed6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ad0cc9953cfff5aa330bb26e4034caed6">requires</a> (!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1concepts.html#ae4a8d3af82a1dd777f5d22860e075374">concepts::Serializable</a>&lt; T, MemT &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a>(T &amp;&amp;elts)</td></tr>
<tr class="memdesc:ad0cc9953cfff5aa330bb26e4034caed6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for containers. They must be iterable.  <a href="structserializer_1_1Serializer.html#ad0cc9953cfff5aa330bb26e4034caed6">More...</a><br /></td></tr>
<tr class="separator:ad0cc9953cfff5aa330bb26e4034caed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90506f0d2b57df4729fb89a12acdfed6"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::Container T&gt; </td></tr>
<tr class="memitem:a90506f0d2b57df4729fb89a12acdfed6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a90506f0d2b57df4729fb89a12acdfed6">requires</a> (!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1concepts.html#ad3aec2f2cffd4e288c5add840bbaa59f">concepts::Deserializable</a>&lt; T, MemT &gt;) inline const expr void <a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a>(T &amp;&amp;elts)</td></tr>
<tr class="memdesc:a90506f0d2b57df4729fb89a12acdfed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for containers..  <a href="structserializer_1_1Serializer.html#a90506f0d2b57df4729fb89a12acdfed6">More...</a><br /></td></tr>
<tr class="separator:a90506f0d2b57df4729fb89a12acdfed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794704114d900d49f9132c64fc0378d4"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::StaticArray T&gt; </td></tr>
<tr class="memitem:a794704114d900d49f9132c64fc0378d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">serialize_</a> (T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a794704114d900d49f9132c64fc0378d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for static arrays.  <a href="structserializer_1_1Serializer.html#a794704114d900d49f9132c64fc0378d4">More...</a><br /></td></tr>
<tr class="separator:a794704114d900d49f9132c64fc0378d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34506a0ccca983d12caaaebb444f6532"><td class="memTemplParams" colspan="2">template&lt;serializer::concepts::StaticArray T&gt; </td></tr>
<tr class="memitem:a34506a0ccca983d12caaaebb444f6532"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">deserialize_</a> (T &amp;&amp;elt)</td></tr>
<tr class="memdesc:a34506a0ccca983d12caaaebb444f6532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for static arrays.  <a href="structserializer_1_1Serializer.html#a34506a0ccca983d12caaaebb444f6532">More...</a><br /></td></tr>
<tr class="separator:a34506a0ccca983d12caaaebb444f6532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acbdcc837d815b97771f22a9eb662b8"><td class="memTemplParams" colspan="2">template&lt;concepts::Pointer T, typename DT , typename... DTs&gt; </td></tr>
<tr class="memitem:a4acbdcc837d815b97771f22a9eb662b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a4acbdcc837d815b97771f22a9eb662b8">serialize_</a> (<a class="el" href="structserializer_1_1tools_1_1DynamicArray.html">tools::DynamicArray</a>&lt; T, DT, DTs... &gt; elt)</td></tr>
<tr class="memdesc:a4acbdcc837d815b97771f22a9eb662b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for dynamic arrays (dynamic arrays should be wrap in the DynamicArray type).  <a href="structserializer_1_1Serializer.html#a4acbdcc837d815b97771f22a9eb662b8">More...</a><br /></td></tr>
<tr class="separator:a4acbdcc837d815b97771f22a9eb662b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b0367fbb2764c2f600e1e857d062ee"><td class="memTemplParams" colspan="2">template&lt;concepts::Pointer T, typename DT , typename... DTs&gt; </td></tr>
<tr class="memitem:aa1b0367fbb2764c2f600e1e857d062ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#aa1b0367fbb2764c2f600e1e857d062ee">deserialize_</a> (<a class="el" href="structserializer_1_1tools_1_1DynamicArray.html">tools::DynamicArray</a>&lt; T, DT, DTs... &gt; elt)</td></tr>
<tr class="memdesc:aa1b0367fbb2764c2f600e1e857d062ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize function for dynamic arrays (dynamic arrays should be wrap in the DynamicArray type). Note: memory is allocated if required. If the pointer is not set correctly, this function may segfault. To avoid pointer management, use the containers of the standard library instead.  <a href="structserializer_1_1Serializer.html#aa1b0367fbb2764c2f600e1e857d062ee">More...</a><br /></td></tr>
<tr class="separator:aa1b0367fbb2764c2f600e1e857d062ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab923c6f000ebd9db3f35fedfd3293e77"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#ab923c6f000ebd9db3f35fedfd3293e77">serialize_</a> (auto &amp;&amp;...elts)</td></tr>
<tr class="memdesc:ab923c6f000ebd9db3f35fedfd3293e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic serialize helper function for custom serializer.  <a href="structserializer_1_1Serializer.html#ab923c6f000ebd9db3f35fedfd3293e77">More...</a><br /></td></tr>
<tr class="separator:ab923c6f000ebd9db3f35fedfd3293e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb89fcb64dab7eca6848983881d78c2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a3bb89fcb64dab7eca6848983881d78c2">deserialize_</a> (auto &amp;&amp;...elts)</td></tr>
<tr class="memdesc:a3bb89fcb64dab7eca6848983881d78c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic deserialize helper function for custom serializer.  <a href="structserializer_1_1Serializer.html#a3bb89fcb64dab7eca6848983881d78c2">More...</a><br /></td></tr>
<tr class="separator:a3bb89fcb64dab7eca6848983881d78c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structserializer_1_1Serialize"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structserializer_1_1Serialize')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structserializer_1_1Serialize.html">serializer::Serialize&lt; AdditionalTypes &gt;</a></td></tr>
<tr class="memitem:aaf1aecad24ec45158f5387eeeecf186b inherit pub_methods_structserializer_1_1Serialize"><td class="memItemLeft" align="right" valign="top"><a id="aaf1aecad24ec45158f5387eeeecf186b"></a>
constexpr virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (AdditionalTypes const &amp;)=0</td></tr>
<tr class="separator:aaf1aecad24ec45158f5387eeeecf186b inherit pub_methods_structserializer_1_1Serialize"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad98e30d4488c05fbcb227b1b02fac76 inherit pub_methods_structserializer_1_1Serialize"><td class="memItemLeft" align="right" valign="top"><a id="aad98e30d4488c05fbcb227b1b02fac76"></a>
constexpr virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>deserialize</b> (AdditionalTypes &amp;)=0</td></tr>
<tr class="separator:aad98e30d4488c05fbcb227b1b02fac76 inherit pub_methods_structserializer_1_1Serialize"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9ae388da2e394cb63d21926359c22297"><td class="memItemLeft" align="right" valign="top"><a id="a9ae388da2e394cb63d21926359c22297"></a>
MemT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a9ae388da2e394cb63d21926359c22297">mem</a></td></tr>
<tr class="memdesc:a9ae388da2e394cb63d21926359c22297"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory buffer in which the serialized data are stored <br /></td></tr>
<tr class="separator:a9ae388da2e394cb63d21926359c22297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d638ee5130e873a5b1b767c1c829e6"><td class="memItemLeft" align="right" valign="top"><a id="a50d638ee5130e873a5b1b767c1c829e6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1Serializer.html#a50d638ee5130e873a5b1b767c1c829e6">pos</a> = 0</td></tr>
<tr class="memdesc:a50d638ee5130e873a5b1b767c1c829e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">position in the memory buffer. <br /></td></tr>
<tr class="separator:a50d638ee5130e873a5b1b767c1c829e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MemT, typename TypeTable = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt;<br />
struct serializer::Serializer&lt; MemT, TypeTable, AdditionalTypes &gt;</h3>

<p>Default serializer that contains the functions for serializing and deserializing types from the standard library. It inherits from the convert behavior for additional types so the user can add its own functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MemT</td><td>Type of the memory buffer. </td></tr>
    <tr><td class="paramname">AdditionalTypes</td><td>External types for which the user can add support. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad7c3270125fb0afbe63cf0d4292400e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c3270125fb0afbe63cf0d4292400e8">&#9670;&nbsp;</a></span>Serializer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::<a class="el" href="structserializer_1_1Serializer.html">Serializer</a> </td>
          <td>(</td>
          <td class="paramtype">MemT &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from memory buffer reference and position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>Memory buffer in which the data is serialized. </td></tr>
    <tr><td class="paramname">pos</td><td>Position in the memory buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad732d2eabf09c34f63b54ded052e3ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad732d2eabf09c34f63b54ded052e3ff8">&#9670;&nbsp;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::append </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for appending a simple elements to the memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>element to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9edbee2456c218489faf3ea85261e443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edbee2456c218489faf3ea85261e443">&#9670;&nbsp;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structserializer_1_1Serializer.html#ace6100db274852fa2b23c6ebaec0a658">byte_type</a> *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a buffer of byptes to the memory (mem and pos are changed) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Buffer of bytes. </td></tr>
    <tr><td class="paramname">nbBytes</td><td>Size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bb89fcb64dab7eca6848983881d78c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb89fcb64dab7eca6848983881d78c2">&#9670;&nbsp;</a></span>deserialize_() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserialize_ </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>elts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic deserialize helper function for custom serializer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elts</td><td>Elements to deserialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34506a0ccca983d12caaaebb444f6532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34506a0ccca983d12caaaebb444f6532">&#9670;&nbsp;</a></span>deserialize_() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::TupleLike T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserialize_ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function tuples (std::tuple and std::pair). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34506a0ccca983d12caaaebb444f6532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34506a0ccca983d12caaaebb444f6532">&#9670;&nbsp;</a></span>deserialize_() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::StaticArray T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserialize_ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for static arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e372fa1e13b701e10be2f40806f6205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e372fa1e13b701e10be2f40806f6205">&#9670;&nbsp;</a></span>deserialize_() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::String T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserialize_ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1b0367fbb2764c2f600e1e857d062ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b0367fbb2764c2f600e1e857d062ee">&#9670;&nbsp;</a></span>deserialize_() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;concepts::Pointer T, typename DT , typename... DTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserialize_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserializer_1_1tools_1_1DynamicArray.html">tools::DynamicArray</a>&lt; T, DT, DTs... &gt;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for dynamic arrays (dynamic arrays should be wrap in the DynamicArray type). Note: memory is allocated if required. If the pointer is not set correctly, this function may segfault. To avoid pointer management, use the containers of the standard library instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2714eae4da0664485d80fa5dc0f659e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2714eae4da0664485d80fa5dc0f659e">&#9670;&nbsp;</a></span>deserializeId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr id_type <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserializeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id </dd></dl>

</div>
</div>
<a id="aa9d323568a1913ae29cdc41e2809c75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d323568a1913ae29cdc41e2809c75e">&#9670;&nbsp;</a></span>deserializeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserializeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for deserializing the size of containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of the size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized size. </dd></dl>

</div>
</div>
<a id="ade0a591c0dea09f516c6b69bf3ca3265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0a591c0dea09f516c6b69bf3ca3265">&#9670;&nbsp;</a></span>deserializeTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;size_t... Idx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::deserializeTuple </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Idx... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for deserializing tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_sequence</td><td>Indicies of the tuple elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb05c5b5ad1decb541e97ead66ffcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb05c5b5ad1decb541e97ead66ffcc9">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Trivial T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1concepts.html#ad3aec2f2cffd4e288c5add840bbaa59f">concepts::Deserializable</a>&lt; T, MemT &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for the trivial types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab592c0b1ac804a47cbcfd9395d8267f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab592c0b1ac804a47cbcfd9395d8267f5">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Trivial T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1concepts.html#ae4a8d3af82a1dd777f5d22860e075374">concepts::Serializable</a>&lt; T, MemT &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the trivial types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90506f0d2b57df4729fb89a12acdfed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90506f0d2b57df4729fb89a12acdfed6">&#9670;&nbsp;</a></span>requires() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Container T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1concepts.html#ad3aec2f2cffd4e288c5add840bbaa59f">concepts::Deserializable</a>&lt; T, MemT &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for containers.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0cc9953cfff5aa330bb26e4034caed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cc9953cfff5aa330bb26e4034caed6">&#9670;&nbsp;</a></span>requires() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Container T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1concepts.html#ae4a8d3af82a1dd777f5d22860e075374">concepts::Serializable</a>&lt; T, MemT &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for containers. They must be iterable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a192faa421c46d03b8a40a77280ab503e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192faa421c46d03b8a40a77280ab503e">&#9670;&nbsp;</a></span>requires() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Enum T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for enum types. The data is stored using the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46af9ccd91e0bf353daecdfd44b6a276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46af9ccd91e0bf353daecdfd44b6a276">&#9670;&nbsp;</a></span>requires() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Enum T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1concepts.html#aa426d1eabf90bf5948154192f1329ddb">concepts::Trivial</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the enum types. The underlying type is used to store the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad958d6cb0e3be7e4052dda5f1fb138a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad958d6cb0e3be7e4052dda5f1fb138a3">&#9670;&nbsp;</a></span>requires() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::ConcretePtr T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for the pointer types. If the pointer is not null, a dynamic allocation is done. This memory should be handled by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad958d6cb0e3be7e4052dda5f1fb138a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad958d6cb0e3be7e4052dda5f1fb138a3">&#9670;&nbsp;</a></span>requires() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::ConcreteSmartPtr T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for smart pointers (unique and shared). A pointer is allocated if required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92946fe12710a000adc48bf84b080710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92946fe12710a000adc48bf84b080710">&#9670;&nbsp;</a></span>requires() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::Pointer T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the pointer types. The pointer should be valid (nullptr or value). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92946fe12710a000adc48bf84b080710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92946fe12710a000adc48bf84b080710">&#9670;&nbsp;</a></span>requires() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::SmartPtr T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceserializer_1_1mtf.html#a899c6310451ae5d12a1bffffb5d8aa67">mtf::contains_v</a>&lt; T, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for smart pointers (unique and shared). The pointer should be valid (nullptr or value). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38ddd344bc11fc894dce52583580915a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddd344bc11fc894dce52583580915a">&#9670;&nbsp;</a></span>requires() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserializer_1_1concepts.html#adc3c62a906cfd8798e058a8ff1ae4f44">concepts::NonAutomaticDeserialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fallback functions for non deserializable types. Here either we use a custom function if it has be implemented or we throw an exception. Note: exceptions are a way to control the display of the error message. We could use a static assert but the message will be lost in the hole compiler error output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3439d043e211277eed3107a974d88897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3439d043e211277eed3107a974d88897">&#9670;&nbsp;</a></span>requires() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserializer_1_1concepts.html#aba8e9255844b9ce33c2d22cecc312ac4">concepts::NonAutomaticSerialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fallback functions for non serializable types. Here either we use a custom function if it has be implemented or we throw an exception. Note: exceptions are a way to control the display of the error message. We could use a static assert but the message will be lost in the hole compiler error output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f69ba041aeb1db8f89dc9963802a6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f69ba041aeb1db8f89dc9963802a6f9">&#9670;&nbsp;</a></span>requires() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserializer_1_1concepts.html#ac86a00ea591f3e6c068e90d187e9b821">concepts::UseDeserialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize function for the deserializable types (they have a deserialize method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe0311a534c9734337cc63040a7eb1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0311a534c9734337cc63040a7eb1bb">&#9670;&nbsp;</a></span>requires() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserializer_1_1concepts.html#a7a51c9c68e56bee183b33f3d11f0f20f">concepts::UseSerialize</a>&lt; T, MemT, AdditionalTypes... &gt; &amp;&amp;!<a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for the serializable types (they have a serialize method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a266bf13770279ce40f906e4fface43ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266bf13770279ce40f906e4fface43ae">&#9670;&nbsp;</a></span>requires() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> a generic type registed in the type table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8a1f270e5f921d88efba2237b18dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8a1f270e5f921d88efba2237b18dfc">&#9670;&nbsp;</a></span>requires() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">tools::has_type_v</a>&lt; T, TypeTable &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> a generic type registed in the type table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab923c6f000ebd9db3f35fedfd3293e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab923c6f000ebd9db3f35fedfd3293e77">&#9670;&nbsp;</a></span>serialize_() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::serialize_ </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>elts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic serialize helper function for custom serializer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elts</td><td>Elements to serialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a794704114d900d49f9132c64fc0378d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794704114d900d49f9132c64fc0378d4">&#9670;&nbsp;</a></span>serialize_() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::TupleLike T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::serialize_ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for tuples (std::tuple and std::pair). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a794704114d900d49f9132c64fc0378d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794704114d900d49f9132c64fc0378d4">&#9670;&nbsp;</a></span>serialize_() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::String T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::serialize_ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a794704114d900d49f9132c64fc0378d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794704114d900d49f9132c64fc0378d4">&#9670;&nbsp;</a></span>serialize_() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;serializer::concepts::StaticArray T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::serialize_ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for static arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4acbdcc837d815b97771f22a9eb662b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acbdcc837d815b97771f22a9eb662b8">&#9670;&nbsp;</a></span>serialize_() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;concepts::Pointer T, typename DT , typename... DTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::serialize_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserializer_1_1tools_1_1DynamicArray.html">tools::DynamicArray</a>&lt; T, DT, DTs... &gt;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structserializer_1_1Serialize.html" title="Used to create a serialize behavior for a specific type. This class is used when we want to create a ...">Serialize</a> function for dynamic arrays (dynamic arrays should be wrap in the DynamicArray type). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae28d294f087c1d1bcc91b564226a864d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28d294f087c1d1bcc91b564226a864d">&#9670;&nbsp;</a></span>serializeTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemT , typename TypeTable  = tools::TypeTable&lt;&gt;, typename... AdditionalTypes&gt; </div>
<div class="memtemplate">
template&lt;size_t... Idx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structserializer_1_1Serializer.html">serializer::Serializer</a>&lt; MemT, TypeTable, AdditionalTypes &gt;::serializeTuple </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Idx... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function used to serialize tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple to serialize. </td></tr>
    <tr><td class="paramname">index_sequence</td><td>Indicies of the tuple elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/rvc1/Documents/dev/projects/serializer/serializer-cpp/serializer/serializer/<a class="el" href="serializer_2serializer_8hpp_source.html">serializer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceserializer.html">serializer</a></li><li class="navelem"><a class="el" href="structserializer_1_1Serializer.html">Serializer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
