<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>serializer-cpp: serializer::tools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">serializer-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceserializer_1_1tools.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">serializer::tools Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace serializer tools  
<a href="namespaceserializer_1_1tools.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1tools_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reporesents the context given the the serializer functions.  <a href="structserializer_1_1tools_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1tools_1_1DynamicArray.html">DynamicArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper object for dynamic arrays (can store references to the variables that contains the array size).  <a href="structserializer_1_1tools_1_1DynamicArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1tools_1_1Super.html">Super</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for serializing the mother class of polymorphic objects. @tparm SuperType Type of the mother class.  <a href="structserializer_1_1tools_1_1Super.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table that is used to get the identifiers of the serialized types.  <a href="structserializer_1_1tools_1_1TypeTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1tools_1_1has__type.html">has_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>T</code> is in <code>Table</code>  <a href="structserializer_1_1tools_1_1has__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserializer_1_1tools_1_1has__type_3_01T_00_01TypeTable_3_01Types_8_8_8_01_4_01_4.html">has_type&lt; T, TypeTable&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aebc3455f169bdf8c3386b2dcc0114f99"><td class="memItemLeft" align="right" valign="top"><a id="aebc3455f169bdf8c3386b2dcc0114f99"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#aebc3455f169bdf8c3386b2dcc0114f99">Phases</a> { <b>Serialization</b>
, <b>Deserialization</b>
 }</td></tr>
<tr class="memdesc:aebc3455f169bdf8c3386b2dcc0114f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum used with the serializer functions to know the stage of the serialization. <br /></td></tr>
<tr class="separator:aebc3455f169bdf8c3386b2dcc0114f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9b410f110c8a07f97c6228cb9c5fc5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9b410f110c8a07f97c6228cb9c5fc5e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#ad9b410f110c8a07f97c6228cb9c5fc5e">requires</a> (sizeof(T)==sizeof(char)) class <a class="el" href="namespaceserializer.html#a04a1bed80988c8fa5dbefabe1efeae07">Bytes</a></td></tr>
<tr class="memdesc:ad9b410f110c8a07f97c6228cb9c5fc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom vector for serialization (std::vector interface is anoying to used for the serialization).  <a href="namespaceserializer_1_1tools.html#ad9b410f110c8a07f97c6228cb9c5fc5e">More...</a><br /></td></tr>
<tr class="separator:ad9b410f110c8a07f97c6228cb9c5fc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1f85781798d845ebaab4ebc6dcdf9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b1f85781798d845ebaab4ebc6dcdf9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a0b1f85781798d845ebaab4ebc6dcdf9c">super</a> (auto *obj)</td></tr>
<tr class="memdesc:a0b1f85781798d845ebaab4ebc6dcdf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for creating a <a class="el" href="structserializer_1_1tools_1_1Super.html" title="Wrapper class for serializing the mother class of polymorphic objects. @tparm SuperType Type of the m...">Super</a> from an object.  <a href="namespaceserializer_1_1tools.html#a0b1f85781798d845ebaab4ebc6dcdf9c">More...</a><br /></td></tr>
<tr class="separator:a0b1f85781798d845ebaab4ebc6dcdf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e328227ee0729043bee63c29eef86d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e328227ee0729043bee63c29eef86d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a5e328227ee0729043bee63c29eef86d4">super</a> (auto const *obj)</td></tr>
<tr class="memdesc:a5e328227ee0729043bee63c29eef86d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for creating a <a class="el" href="structserializer_1_1tools_1_1Super.html" title="Wrapper class for serializing the mother class of polymorphic objects. @tparm SuperType Type of the m...">Super</a> from an const object.  <a href="namespaceserializer_1_1tools.html#a5e328227ee0729043bee63c29eef86d4">More...</a><br /></td></tr>
<tr class="separator:a5e328227ee0729043bee63c29eef86d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cb375a4bfcdbd37810470a49adfe88"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:a89cb375a4bfcdbd37810470a49adfe88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceserializer_1_1tools.html#ad9b410f110c8a07f97c6228cb9c5fc5e">requires</a> constexpr <a class="el" href="namespaceserializer_1_1concepts.html#aac9b8925d8caf86dfb2e725c900e085a">serializer::concepts::Insertable</a>&lt; Container, T &gt; void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a89cb375a4bfcdbd37810470a49adfe88">insert</a> (Container &amp;&amp;container, T &amp;&amp;element)</td></tr>
<tr class="memdesc:a89cb375a4bfcdbd37810470a49adfe88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into an iterable using the insert member function.  <a href="namespaceserializer_1_1tools.html#a89cb375a4bfcdbd37810470a49adfe88">More...</a><br /></td></tr>
<tr class="separator:a89cb375a4bfcdbd37810470a49adfe88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d251dd934a7564d1235e06d8e7c75b3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:a7d251dd934a7564d1235e06d8e7c75b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceserializer_1_1tools.html#ad9b410f110c8a07f97c6228cb9c5fc5e">requires</a> constexpr <a class="el" href="namespaceserializer_1_1concepts.html#ae485117d22d9cf220c06720aba15dbef">serializer::concepts::PushBackable</a>&lt; Container, T &gt; void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a7d251dd934a7564d1235e06d8e7c75b3">insert</a> (Container &amp;&amp;container, T &amp;&amp;element)</td></tr>
<tr class="memdesc:a7d251dd934a7564d1235e06d8e7c75b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into an iterable using the add member function.  <a href="namespaceserializer_1_1tools.html#a7d251dd934a7564d1235e06d8e7c75b3">More...</a><br /></td></tr>
<tr class="separator:a7d251dd934a7564d1235e06d8e7c75b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa077b0c54406013ae12398c06c994d5e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:aa077b0c54406013ae12398c06c994d5e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#aa077b0c54406013ae12398c06c994d5e">insert</a> (Container &amp;&amp;container, T &amp;&amp;element, size_t idx)</td></tr>
<tr class="memdesc:aa077b0c54406013ae12398c06c994d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into an iterable using the operator[].  <a href="namespaceserializer_1_1tools.html#aa077b0c54406013ae12398c06c994d5e">More...</a><br /></td></tr>
<tr class="separator:aa077b0c54406013ae12398c06c994d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d008b1adfffa46a11903b208727fed"><td class="memTemplParams" colspan="2">template&lt;typename H , typename... Types, size_t... Idx&gt; </td></tr>
<tr class="memitem:ad9d008b1adfffa46a11903b208727fed"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#ad9d008b1adfffa46a11903b208727fed">tuplePopFront_</a> (std::tuple&lt; H, Types... &gt; const &amp;tuple, std::index_sequence&lt; Idx... &gt;)</td></tr>
<tr class="memdesc:ad9d008b1adfffa46a11903b208727fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element of a tuple.  <a href="namespaceserializer_1_1tools.html#ad9d008b1adfffa46a11903b208727fed">More...</a><br /></td></tr>
<tr class="separator:ad9d008b1adfffa46a11903b208727fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e804768a64eff6de88cd62e869e2cd"><td class="memTemplParams" colspan="2">template&lt;typename H , typename... Types&gt; </td></tr>
<tr class="memitem:a78e804768a64eff6de88cd62e869e2cd"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a78e804768a64eff6de88cd62e869e2cd">tuplePopFront</a> (std::tuple&lt; H, Types... &gt; const &amp;tuple)</td></tr>
<tr class="memdesc:a78e804768a64eff6de88cd62e869e2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element of a tuple.  <a href="namespaceserializer_1_1tools.html#a78e804768a64eff6de88cd62e869e2cd">More...</a><br /></td></tr>
<tr class="separator:a78e804768a64eff6de88cd62e869e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c473d9a03e9e5438917fc41075e71f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types, size_t... Idx&gt; </td></tr>
<tr class="memitem:a2c473d9a03e9e5438917fc41075e71f0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a2c473d9a03e9e5438917fc41075e71f0">tupleProd_</a> (std::tuple&lt; Types... &gt; const &amp;tuple, std::index_sequence&lt; Idx... &gt;)</td></tr>
<tr class="memdesc:a2c473d9a03e9e5438917fc41075e71f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements in a tuple.  <a href="namespaceserializer_1_1tools.html#a2c473d9a03e9e5438917fc41075e71f0">More...</a><br /></td></tr>
<tr class="separator:a2c473d9a03e9e5438917fc41075e71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d34fdeafe021d9fea4edd20168b0621"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a0d34fdeafe021d9fea4edd20168b0621"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a0d34fdeafe021d9fea4edd20168b0621">tupleProd</a> (std::tuple&lt; Types... &gt; const &amp;tuple)</td></tr>
<tr class="memdesc:a0d34fdeafe021d9fea4edd20168b0621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements in a tuple.  <a href="namespaceserializer_1_1tools.html#a0d34fdeafe021d9fea4edd20168b0621">More...</a><br /></td></tr>
<tr class="separator:a0d34fdeafe021d9fea4edd20168b0621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0c71696cb5080e89f78a9af09d40cf"><td class="memTemplParams" colspan="2">template&lt;typename Ser , typename T &gt; </td></tr>
<tr class="memitem:a0a0c71696cb5080e89f78a9af09d40cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a0a0c71696cb5080e89f78a9af09d40cf">deserializerAccessor</a> (Ser &amp;serializer, auto &amp;obj, T accessor)</td></tr>
<tr class="memdesc:a0a0c71696cb5080e89f78a9af09d40cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize the attribute accessible with <code>accessor</code>.  <a href="namespaceserializer_1_1tools.html#a0a0c71696cb5080e89f78a9af09d40cf">More...</a><br /></td></tr>
<tr class="separator:a0a0c71696cb5080e89f78a9af09d40cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24918b9ad13f27fc57c73525768f6be8"><td class="memTemplParams" colspan="2">template&lt;typename Ser &gt; </td></tr>
<tr class="memitem:a24918b9ad13f27fc57c73525768f6be8"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a24918b9ad13f27fc57c73525768f6be8">deserializerAccessors</a> (auto &amp;mem, size_t pos, auto &amp;obj, auto &amp;&amp;...accessors)</td></tr>
<tr class="memdesc:a24918b9ad13f27fc57c73525768f6be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize the attributes accessible with the <code>accessors</code>.  <a href="namespaceserializer_1_1tools.html#a24918b9ad13f27fc57c73525768f6be8">More...</a><br /></td></tr>
<tr class="separator:a24918b9ad13f27fc57c73525768f6be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5e11debf8b15ce072432c8025af657"><td class="memTemplParams" colspan="2"><a id="acd5e11debf8b15ce072432c8025af657"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:acd5e11debf8b15ce072432c8025af657"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#acd5e11debf8b15ce072432c8025af657">hasId</a> (size_t id, <a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; Types... &gt;)</td></tr>
<tr class="memdesc:acd5e11debf8b15ce072432c8025af657"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>id</code> is in <code>Table</code> <br /></td></tr>
<tr class="separator:acd5e11debf8b15ce072432c8025af657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde826087bf76d199ebeb0b8e7e01a79"><td class="memTemplParams" colspan="2">template&lt;typename Target , typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:adde826087bf76d199ebeb0b8e7e01a79"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;::id_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#adde826087bf76d199ebeb0b8e7e01a79">getId</a> (<a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;)</td></tr>
<tr class="memdesc:adde826087bf76d199ebeb0b8e7e01a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the Target type stored in the given table type.  <a href="namespaceserializer_1_1tools.html#adde826087bf76d199ebeb0b8e7e01a79">More...</a><br /></td></tr>
<tr class="separator:adde826087bf76d199ebeb0b8e7e01a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594bfcf92dd66e7212ae2fc585a74e49"><td class="memTemplParams" colspan="2">template&lt;typename TypeTable &gt; </td></tr>
<tr class="memitem:a594bfcf92dd66e7212ae2fc585a74e49"><td class="memTemplItemLeft" align="right" valign="top">constexpr TypeTable::id_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a594bfcf92dd66e7212ae2fc585a74e49">getId</a> (auto &amp;mem, size_t pos=0)</td></tr>
<tr class="memdesc:a594bfcf92dd66e7212ae2fc585a74e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a type from mem at pos.  <a href="namespaceserializer_1_1tools.html#a594bfcf92dd66e7212ae2fc585a74e49">More...</a><br /></td></tr>
<tr class="separator:a594bfcf92dd66e7212ae2fc585a74e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c8c6e186b0e593f7c55efabb272ebc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4c8c6e186b0e593f7c55efabb272ebc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#aa4c8c6e186b0e593f7c55efabb272ebc">create</a> (auto &amp;elt)</td></tr>
<tr class="memdesc:aa4c8c6e186b0e593f7c55efabb272ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer of type T and put the result in elt. The pointer can be shared, unique or a standard pointer. Note: if the element is not a pointer the function does nothing.  <a href="namespaceserializer_1_1tools.html#aa4c8c6e186b0e593f7c55efabb272ebc">More...</a><br /></td></tr>
<tr class="separator:aa4c8c6e186b0e593f7c55efabb272ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c78e2de9fd19c77a3601963bc74a38"><td class="memTemplParams" colspan="2">template&lt;typename SuperType , typename IdType , typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:af1c78e2de9fd19c77a3601963bc74a38"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#af1c78e2de9fd19c77a3601963bc74a38">createPolymorphic</a> (IdType id, <a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;, SuperType &amp;elt)</td></tr>
<tr class="memdesc:af1c78e2de9fd19c77a3601963bc74a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a polymorphic type. The real type is found using the given id.  <a href="namespaceserializer_1_1tools.html#af1c78e2de9fd19c77a3601963bc74a38">More...</a><br /></td></tr>
<tr class="separator:af1c78e2de9fd19c77a3601963bc74a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6033c3fef04b32c0783c825628761d"><td class="memTemplParams" colspan="2">template&lt;typename TypeTable &gt; </td></tr>
<tr class="memitem:aba6033c3fef04b32c0783c825628761d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#aba6033c3fef04b32c0783c825628761d">createId</a> (auto id, auto &amp;elt)</td></tr>
<tr class="memdesc:aba6033c3fef04b32c0783c825628761d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a element using the identifier.  <a href="namespaceserializer_1_1tools.html#aba6033c3fef04b32c0783c825628761d">More...</a><br /></td></tr>
<tr class="separator:aba6033c3fef04b32c0783c825628761d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74b5202b9a609fe905ec9fe14c6a227"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ae74b5202b9a609fe905ec9fe14c6a227"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#ae74b5202b9a609fe905ec9fe14c6a227">applyId</a> (auto id, <a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;, auto function)</td></tr>
<tr class="memdesc:ae74b5202b9a609fe905ec9fe14c6a227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a template lambda to the type with the identifier <code>id</code> in the given type table.  <a href="namespaceserializer_1_1tools.html#ae74b5202b9a609fe905ec9fe14c6a227">More...</a><br /></td></tr>
<tr class="separator:ae74b5202b9a609fe905ec9fe14c6a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a302aede0d36fabb09a31f050a18429a6"><td class="memTemplParams" colspan="2"><a id="a302aede0d36fabb09a31f050a18429a6"></a>
template&lt;typename T , typename Table &gt; </td></tr>
<tr class="memitem:a302aede0d36fabb09a31f050a18429a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserializer_1_1tools.html#a302aede0d36fabb09a31f050a18429a6">has_type_v</a> = <a class="el" href="structserializer_1_1tools_1_1has__type.html">has_type</a>&lt;<a class="el" href="namespaceserializer_1_1mtf.html#a0428c5a283c87d77687ae142912bc9bc">mtf::base_t</a>&lt;T&gt;, Table&gt;::value</td></tr>
<tr class="memdesc:a302aede0d36fabb09a31f050a18429a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>T</code> is in <code>Table</code> <br /></td></tr>
<tr class="separator:a302aede0d36fabb09a31f050a18429a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace serializer tools </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae74b5202b9a609fe905ec9fe14c6a227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74b5202b9a609fe905ec9fe14c6a227">&#9670;&nbsp;</a></span>applyId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void serializer::tools::applyId </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a template lambda to the type with the identifier <code>id</code> in the given type table. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>First type in the type table. </td></tr>
    <tr><td class="paramname">Ts</td><td>Rest of the types in the type table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Identifier of the target type. </td></tr>
    <tr><td class="paramname">_</td><td>Type table. </td></tr>
    <tr><td class="paramname">function</td><td>Template lambda / functor to apply on the type. the operator() should be template parametrized with a type T that will correspond to the type of identifier id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4c8c6e186b0e593f7c55efabb272ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c8c6e186b0e593f7c55efabb272ebc">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void serializer::tools::create </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pointer of type T and put the result in elt. The pointer can be shared, unique or a standard pointer. Note: if the element is not a pointer the function does nothing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>Element that will contain the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Error</td><td>when T is an abstract class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba6033c3fef04b32c0783c825628761d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6033c3fef04b32c0783c825628761d">&#9670;&nbsp;</a></span>createId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeTable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void serializer::tools::createId </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>elt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a element using the identifier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structserializer_1_1tools_1_1TypeTable.html" title="Table that is used to get the identifiers of the serialized types.">TypeTable</a></td><td>The type table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Identifier of the type to create. </td></tr>
    <tr><td class="paramname">elt</td><td>Element that will contain the created type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Error</td><td>when the id is not in the given type table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1c78e2de9fd19c77a3601963bc74a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c78e2de9fd19c77a3601963bc74a38">&#9670;&nbsp;</a></span>createPolymorphic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SuperType , typename IdType , typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void serializer::tools::createPolymorphic </td>
          <td>(</td>
          <td class="paramtype">IdType&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SuperType &amp;&#160;</td>
          <td class="paramname"><em>elt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a polymorphic type. The real type is found using the given id. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SuperType</td><td>Type of the element. </td></tr>
    <tr><td class="paramname">T</td><td>Firt type in the table. </td></tr>
    <tr><td class="paramname">Ts</td><td>Rest of the types in the table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Identifier of the target type. @parma _ Type table. @parma elt Deserialize element, it will contains the result object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a0c71696cb5080e89f78a9af09d40cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0c71696cb5080e89f78a9af09d40cf">&#9670;&nbsp;</a></span>deserializerAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ser , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void serializer::tools::deserializerAccessor </td>
          <td>(</td>
          <td class="paramtype">Ser &amp;&#160;</td>
          <td class="paramname"><em>serializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize the attribute accessible with <code>accessor</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ser</td><td><a class="el" href="structserializer_1_1Serializer.html" title="Default serializer that contains the functions for serializing and deserializing types from the stand...">Serializer</a> </td></tr>
    <tr><td class="paramname">T</td><td>Type of the accessor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>Bytes containing the serialized data. </td></tr>
    <tr><td class="paramname">pos</td><td>Position in the byte buffer. </td></tr>
    <tr><td class="paramname">obj</td><td>Object to deserialize. </td></tr>
    <tr><td class="paramname">accessor</td><td>Accessor for the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24918b9ad13f27fc57c73525768f6be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24918b9ad13f27fc57c73525768f6be8">&#9670;&nbsp;</a></span>deserializerAccessors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ser &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t serializer::tools::deserializerAccessors </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;...&#160;</td>
          <td class="paramname"><em>accessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize the attributes accessible with the <code>accessors</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ser</td><td><a class="el" href="structserializer_1_1Serializer.html" title="Default serializer that contains the functions for serializing and deserializing types from the stand...">Serializer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>Bytes containing the serialized data. </td></tr>
    <tr><td class="paramname">pos</td><td>Position in the byte buffer. </td></tr>
    <tr><td class="paramname">obj</td><td>Object to deserialize. </td></tr>
    <tr><td class="paramname">accessors</td><td>Accessors for the attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the next object in the byte buffer. </dd></dl>

</div>
</div>
<a id="a594bfcf92dd66e7212ae2fc585a74e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594bfcf92dd66e7212ae2fc585a74e49">&#9670;&nbsp;</a></span>getId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeTable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TypeTable::id_type serializer::tools::getId </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a type from mem at pos. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>Buffer containing the serialized data. </td></tr>
    <tr><td class="paramname">pos</td><td>Start position in the buffer where the id is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adde826087bf76d199ebeb0b8e7e01a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde826087bf76d199ebeb0b8e7e01a79">&#9670;&nbsp;</a></span>getId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt;T, Ts...&gt;::id_type serializer::tools::getId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserializer_1_1tools_1_1TypeTable.html">TypeTable</a>&lt; T, Ts... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of the Target type stored in the given table type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Target</td><td>Target type. </td></tr>
    <tr><td class="paramname">T</td><td>Firt type in the table. </td></tr>
    <tr><td class="paramname">Ts</td><td>Rest of the types in the table. @parma _ Type table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89cb375a4bfcdbd37810470a49adfe88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cb375a4bfcdbd37810470a49adfe88">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceserializer_1_1tools.html#ad9b410f110c8a07f97c6228cb9c5fc5e">requires</a> constexpr <a class="el" href="namespaceserializer_1_1concepts.html#aac9b8925d8caf86dfb2e725c900e085a">serializer::concepts::Insertable</a>&lt;Container, T&gt; void serializer::tools::insert </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element into an iterable using the insert member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Container type. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the lement to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td></td></tr>
    <tr><td class="paramname">element</td><td>element to insert in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d251dd934a7564d1235e06d8e7c75b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d251dd934a7564d1235e06d8e7c75b3">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceserializer_1_1tools.html#ad9b410f110c8a07f97c6228cb9c5fc5e">requires</a> constexpr <a class="el" href="namespaceserializer_1_1concepts.html#ae485117d22d9cf220c06720aba15dbef">serializer::concepts::PushBackable</a>&lt;Container, T&gt; void serializer::tools::insert </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element into an iterable using the add member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Container type. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the lement to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td></td></tr>
    <tr><td class="paramname">element</td><td>element to insert in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa077b0c54406013ae12398c06c994d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa077b0c54406013ae12398c06c994d5e">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void serializer::tools::insert </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element into an iterable using the operator[]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Container type. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the lement to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td></td></tr>
    <tr><td class="paramname">element</td><td>element to insert in the container. </td></tr>
    <tr><td class="paramname">idx</td><td>Index where the element should be inserted in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9b410f110c8a07f97c6228cb9c5fc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b410f110c8a07f97c6228cb9c5fc5e">&#9670;&nbsp;</a></span>requires()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">serializer::tools::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(T)&#160;</td>
          <td class="paramname"> = <code>=&#160;sizeof(char)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom vector for serialization (std::vector interface is anoying to used for the serialization). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Byte type (std::byte, uint8_t, char, ...). </td></tr>
  </table>
  </dd>
</dl>
<p>Default constructor.</p>
<p>Constructor with capacity.</p>
<p>constructor with a pointer and a size</p>
<p>Copy constructor.</p>
<p>Move constructor.</p>
<p>Destructor.</p>
<p>Returns a pointer to the bytes buffer.</p>
<p>Returns a const pointer to the bytes buffer.</p>
<p>Returns the current capacity of the buffer.</p>
<p>Returns the number of bytes stored in the buffer.</p>
<p>@breif Clear the buffer (set the size to 0 but do not reallocate).</p>
<p>Appends some bytes at pos. The function is called "append" and not "insert" because the size is always equal to <code>pos + count</code> at the end. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position where the bytes are appended. </td></tr>
    <tr><td class="paramname">bytes</td><td>Buffer of bytes to append. </td></tr>
    <tr><td class="paramname">nbBytes</td><td>Number of bytes to append.</td></tr>
  </table>
  </dd>
</dl>
<p>Increase the capacity of the memory buffer if size bytes cannot be stored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>New size.</td></tr>
  </table>
  </dd>
</dl>
<p>Reallocate memory and change the capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>New capacity of the the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Give read/write access to the byte <code>idx</code>.</p>
<p>Give read access to the byte <code>idx</code></p>
<p>Copy assignment</p>
<p>Move assignment</p>
<p>Create a std::vector from the memory buffer.</p>
<p>&lt; bytes buffer</p>
<p>&lt; capacity of the buffer</p>
<p>&lt; number of bytes stored</p>

</div>
</div>
<a id="a0b1f85781798d845ebaab4ebc6dcdf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1f85781798d845ebaab4ebc6dcdf9c">&#9670;&nbsp;</a></span>super() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto serializer::tools::super </td>
          <td>(</td>
          <td class="paramtype">auto *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for creating a <a class="el" href="structserializer_1_1tools_1_1Super.html" title="Wrapper class for serializing the mother class of polymorphic objects. @tparm SuperType Type of the m...">Super</a> from an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the object (this). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e328227ee0729043bee63c29eef86d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e328227ee0729043bee63c29eef86d4">&#9670;&nbsp;</a></span>super() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto serializer::tools::super </td>
          <td>(</td>
          <td class="paramtype">auto const *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for creating a <a class="el" href="structserializer_1_1tools_1_1Super.html" title="Wrapper class for serializing the mother class of polymorphic objects. @tparm SuperType Type of the m...">Super</a> from an const object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the object (this). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78e804768a64eff6de88cd62e869e2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e804768a64eff6de88cd62e869e2cd">&#9670;&nbsp;</a></span>tuplePopFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;Types...&gt; serializer::tools::tuplePopFront </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; H, Types... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first element of a tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">H</td><td>First type of the tuple. </td></tr>
    <tr><td class="paramname">Tyes</td><td>Other types in the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tail of the tuple. </dd></dl>

</div>
</div>
<a id="ad9d008b1adfffa46a11903b208727fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d008b1adfffa46a11903b208727fed">&#9670;&nbsp;</a></span>tuplePopFront_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H , typename... Types, size_t... Idx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;Types...&gt; serializer::tools::tuplePopFront_ </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; H, Types... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Idx... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first element of a tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">H</td><td>First type of the tuple. </td></tr>
    <tr><td class="paramname">Tyes</td><td>Other types in the tuple. </td></tr>
    <tr><td class="paramname">Idx</td><td>Indicies in the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Tuple. </td></tr>
    <tr><td class="paramname">index_sequence</td><td>Indicies of the elements of the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tail of the tuple. </dd></dl>

</div>
</div>
<a id="a0d34fdeafe021d9fea4edd20168b0621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d34fdeafe021d9fea4edd20168b0621">&#9670;&nbsp;</a></span>tupleProd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T serializer::tools::tupleProd </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Types... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply the elements in a tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Output type. </td></tr>
    <tr><td class="paramname">Types</td><td>Types in the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c473d9a03e9e5438917fc41075e71f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c473d9a03e9e5438917fc41075e71f0">&#9670;&nbsp;</a></span>tupleProd_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types, size_t... Idx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T serializer::tools::tupleProd_ </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Types... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Idx... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply the elements in a tuple. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Output type. </td></tr>
    <tr><td class="paramname">Types</td><td>Types in the tuple. @tparma Idx Index sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple. </td></tr>
    <tr><td class="paramname">index_sequence</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceserializer.html">serializer</a></li><li class="navelem"><a class="el" href="namespaceserializer_1_1tools.html">tools</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
